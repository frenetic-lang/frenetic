Chapter 8:  Dynamic NetCore
===========================

So far in this tutorial, we have used NetCore to write static network
policies --- policies that do not change in response to network traffic or
topology events such as a switch coming up or going down.  In general,
crafting a dynamic policy amounts to writing a program that generates a
*stream* of static policies.  For instance, a new static policy can be generated
each time a new switch comes on line or the load in the network reaches
some threshold or a new connection is initiated.  

NetCoreDSL makes it possible to experiment with simple dynamic
policies by providing a small number of dynamic building blocks
including a learning switch and a NAT box.  Intuitively, to create
a dynamic policy, one writes an ordinary static policy that 
includes a reference to a dynamic building block:

```
let policy = ... static_component ... dynamic_component ...
```
If the <code>dynamic_component</code> generates the following series of 
policies as it executes:
```
dynamic1

dynamic2

dynamic3 

...
```
then <code>policy</code> will be:
```
... static_component ... dynamic1 ...

... static_component ... dynamic2 ...

... static_component ... dynamic3 ...

...
```
In other words, the static components remain fixed as the dynamic subcomponent
fluctuates from one variant to the next.

In the general Frenetic programming environment, one can build arbitrary,
stateful, event-driven dynamic controllers that produce streams of
NetCore policies.  In NetCoreDSL, you cannot define new dynamic building
blocks yourself, but you may use the dynamic components provided
to you inside your otherwise static policies.

### Programming with a Network Address Translator

In this example, we will investigate how to use a dynamic NAT
component to support connections initiated from a private machine "on
the inside," behind a public IP, to a remote machine "on the outside."
More specifically, when a machine on the inside initiates a connection
to a machine on the outside, our NAT box will pick a new, available public
port, and rewrite the source IP and port to use the available port and
the public IP. Responses to a previously established port are rewritten
to use the private source port and IP.

To use the built-in <code>nat</code> box, the programmer supplies it with 
a desired public IP address (say, <code>10.0.0.254</code>) and invokes it 
as follows.
```
let translatePrivate, translatePublic = nat (publicIP = 10.0.0.254)
in ...
```
The expression above generates a pair of dynamic 
components:  (1) <code>translatePrivate</code>, which
rewrites requests travelling from inside to 
outside, and (2) <code>translatePublic</code>, which rewrites requests 
travelling
from outside back in.  These two components can be used within the
policy following the keyword <code>in</code>.  The following
code defines <code>natter</code>, a complete, dynamic translation
component that expects hosts attached to switch 1, port 1 to be
"on the inside" and hosts attached to switch 1, port 2 to be
"on the outside."
```
let natter =
  let translatePrivate, translatePublic = 
    nat (publicIP = 10.0.0.254) 
  in
    if switch = 1 && inPort = 1 then 
      (translatePrivate; if inPort = 1 then fwd(2) else pass)
  + if switch = 1 && inPort = 2 then
      (translatePublic; if inPort = 2 then fwd(1) else pass)
```
We will use <code>natter</code> inside the following
simple application.
```
let app =
  if frameType = arp then all
  else monitorPolicy(natter)  
```
This application handles arp separately.  It also uses a new feature,
<code>monitorPolicy</code>, to print the series of static
policies generated by the dynamic <code>natter</code> component.
(You can use <code>monitorPolicy</code> in conjunction with static
policies too --- it just isn't very interesting since nothing changes.)

To experiment with the nat box, begin by starting up mininet as
follows.
```
$ sudo mn  --controller=remote --mac
```
Next, launch <code>Nat.nc</code>. 
```
$ frenetic Nat.nc
```
As soon as you start <code>Nat.nc</code>, it should print out the
initial policy:
```
if switch = 1 && inPort = 1 then (controller; if inPort = 1 then 2 else pass)
  else drop
+
if switch = 1 && inPort = 2 then (controller; if inPort = 2 then 1 else pass)
  else drop
```
The printed policy is identical to <code>natter</code>
except that the dynamic components
<code>translate_private</code> and <code>translate_public</code>
have been replaced by the <code>controller</code> action.
The <code>controller</code> action, as you might expect, directs 
packets to the controller for processing by a Frenetic handler,
which decides, based on the packet received and its current state,
what static NetCore policy to generate next.  NetCoreDSL programmers
do not have access to the <code>controller</code> (it is not useful
without the ability to write general-purpose handler code --- a
capability beyond the scope of this simple DSL), but it is used
internally to support our dynamic applications.

To see the <code>natter</code> in action, you will need to prime your arp cache 
on host h2 and start a simple web server running.
```
mininet> h2 arp -s 10.0.0.254 00:00:00:00:00:01
mininet> h2 python -m SimpleHTTPServer 80 . &
```
Now, try fetching a web page from the server:
```
h1 wget -O - 10.0.0.2
```
You should now see several new messages in the controller window.
The first is from the NAT box.  It should look like this:
```
[NAT] translating 10.0.0.1:53591 to 10.0.0.254:2000
```
It tells you which private port (53591) and public port (2000) were used.
Next, you should see the new policy that was generated.  It
looks like this:
```
if switch = 1 && inPort = 1
  then
    (if
     frameType = ip && srcIP = 10.0.0.1
     && frameType = ip && nwProto = tcp && tcpSrcPort = 53591
       then (nwSrc 10.0.0.1->10.0.0.254; pass; tpSrc 53591->2000; pass)
       else controller;
     if inPort = 1 then 2 else pass)
  else drop
+
if switch = 1 && inPort = 2
  then
    (if
     frameType = ip && dstIP = 10.0.0.254
     && frameType = ip && nwProto = tcp && tcpDstPort = 2000
       then (nwDst 10.0.0.254->10.0.0.1; pass; tpDst 2000->53591; pass)
       else controller;
     if inPort = 2 then 1 else pass)
  else drop
```
What has happened is that the new policy is a dynamically specialized
version of the old policy.  Whereas the old policy
sent *all* packets entering switch 1 on port 1 to the controller
(using the <code>controller</code> action), the new policy handles *some*
of those packets in the data plane.  Others will continue to be sent
to the controller.  In particular, TCP packets
destinated for the public IP 10.0.0.254, port 2000, will now be handled on the
switch.  Those are the packets that satisfy this newly embedded predicate:
```
frameType = ip && dstIP = 10.0.0.254 && nwProto = tcp && tcpDstPort = 2000
```
Try making some additional requests to the web server to see how the
policy changes.

Summary
-------

NetCore rocks!  QED.

[topo_1]: images/topo_1.png "Default Mininet topology."
[topo_2]: images/topo_2.png "Simple linear topology."
[topo_3]: images/topo_3.png "Simple tree topology."
