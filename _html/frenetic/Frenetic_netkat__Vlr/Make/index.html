<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (frenetic.Frenetic_netkat__Vlr.Make)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">frenetic</a> &#x00BB; <a href="../index.html">Frenetic_netkat__Vlr</a> &#x00BB; Make</nav><h1>Module <code>Frenetic_netkat__Vlr.Make</code></h1><p>Variable-Lattice-Result</p><p>This module implements a variant of a binary decision diagrams. Rather than representing boolean-valued functions over boolean variables, this data structure represents functions that take on values in a semi-ring, and whose variables are assigned values from a lattice, i.e., that are partially ordered.</p></header><h3 class="heading">Parameters</h3><dl><code><a href="argument-3-R/index.html">R</a> : <a href="../index.html#module-type-Result">Result</a></code><code><a href="argument-2-L/index.html">L</a> : <a href="../index.html#module-type-Lattice">Lattice</a></code><code><a href="argument-1-V/index.html">V</a> : <a href="../index.html#module-type-HashCmp">HashCmp</a></code></dl><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><span class="keyword">private </span>int</code></dt><dd><p>A decision diagram index. All diagrams and subdiagrams within it are given an index. You can convert this to a tree with <code>unget</code>, and from a tree with <code>get</code>.</p></dd></dl><dl><dt class="spec type" id="type-v"><a href="#type-v" class="anchor"></a><code><span class="keyword">type </span>v</code><code><span class="keyword"> = </span><a href="argument-1-V/index.html#type-t">V.t</a><span class="keyword"> * </span><a href="argument-2-L/index.html#type-t">L.t</a></code></dt><dd><p>The type of a variable in the decision diagram.</p></dd></dl><dl><dt class="spec type" id="type-r"><a href="#type-r" class="anchor"></a><code><span class="keyword">type </span>r</code><code><span class="keyword"> = </span><a href="argument-3-R/index.html#type-t">R.t</a></code></dt><dd><p>The type of the result of a decision diagram</p></dd></dl><dl><dt class="spec type" id="type-d"><a href="#type-d" class="anchor"></a><code><span class="keyword">type </span>d</code><code><span class="keyword"> = </span><span class="keyword">private </span></code><table class="variant"><tr id="type-d.Leaf" class="anchored"><td class="def constructor"><a href="#type-d.Leaf" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Leaf</span><span class="keyword"> of </span><a href="index.html#type-r">r</a></code></td></tr><tr id="type-d.Branch" class="anchored"><td class="def constructor"><a href="#type-d.Branch" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Branch</span><span class="keyword"> of </span></code><code>{</code><table class="record"><tr id="type-d.test" class="anchored"><td class="def field"><a href="#type-d.test" class="anchor"></a><code>test : <a href="index.html#type-v">v</a>;</code></td></tr><tr id="type-d.tru" class="anchored"><td class="def field"><a href="#type-d.tru" class="anchor"></a><code>tru : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-d.fls" class="anchored"><td class="def field"><a href="#type-d.fls" class="anchor"></a><code>fls : <a href="index.html#type-t">t</a>;</code></td></tr><tr id="type-d.all_fls" class="anchored"><td class="def field"><a href="#type-d.all_fls" class="anchor"></a><code>all_fls : <a href="index.html#type-t">t</a>;</code></td></tr></table><code>}</code><code></code></td></tr></table></dt></dl><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><code><span class="keyword">module </span>Tbl : Core.Hashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Tbl">Tbl</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div><div class="spec module" id="module-BinTbl"><a href="#module-BinTbl" class="anchor"></a><code><span class="keyword">module </span>BinTbl : Core.Hashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-BinTbl">BinTbl</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></div><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val </span>get : <a href="index.html#type-d">d</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-unget"><a href="#val-unget" class="anchor"></a><code><span class="keyword">val </span>unget : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-d">d</a></code></dt><dt class="spec value" id="val-get_uid"><a href="#val-get_uid" class="anchor"></a><code><span class="keyword">val </span>get_uid : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-drop"><a href="#val-drop" class="anchor"></a><code><span class="keyword">val </span>drop : <a href="index.html#type-t">t</a></code></dt><dd><p><code>drop</code> returns the leaf for a drop operation, which is always present as a leaf node</p></dd></dl><dl><dt class="spec value" id="val-id"><a href="#val-id" class="anchor"></a><code><span class="keyword">val </span>id : <a href="index.html#type-t">t</a></code></dt><dd><p><code>id</code> returns the leaf for the identity operation, which is always present as a leaf node</p></dd></dl><dl><dt class="spec value" id="val-const"><a href="#val-const" class="anchor"></a><code><span class="keyword">val </span>const : <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>const r</code> creates a constant diagram out of <code>r</code>. It's essentially a leaf node with a constant.</p></dd></dl><dl><dt class="spec value" id="val-atom"><a href="#val-atom" class="anchor"></a><code><span class="keyword">val </span>atom : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>atom v t f</code> creates a diagram that checks the variable assignment <code>v</code> holds and returns the result <code>t</code> if it does hold, and the result <code>f</code> otherwise.</p></dd></dl><dl><dt class="spec value" id="val-cond"><a href="#val-cond" class="anchor"></a><code><span class="keyword">val </span>cond : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>cond v t f</code> creates a diagram with pattern v, true-branch t and false-branch f.</p></dd></dl><dl><dt class="spec value" id="val-unchecked_cond"><a href="#val-unchecked_cond" class="anchor"></a><code><span class="keyword">val </span>unchecked_cond : <a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Unsafe!! <code>unchecked_cond v t f</code> behaves like <code>cond v t f</code>, but always puts the pattern <code>v</code> in the root node, without ensuring the FDD-ordering invariant is enforced. Only use this if you know what you are doing!</p></dd></dl><dl><dt class="spec value" id="val-restrict"><a href="#val-restrict" class="anchor"></a><code><span class="keyword">val </span>restrict : <a href="index.html#type-v">v</a> list <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>restrict vs t</code> returns a diagram derived from <code>t</code> and that agrees with <code>t</code> when every variable assignment <code>v</code> in <code>vs</code> is true. This will eliminate the variables in <code>vs</code> from the diagram, if present.</p><p>This function assumes that a variable will only appear once in the list of variable assignments. If the list assigns multiple values to a variable, then the behavior is unspecified.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sum a b</code> returns the disjunction of the two diagrams. The <code>sum</code> operation on the <code>r</code> type is used to combine leaf nodes.</p></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val </span>prod : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>prod a b</code> returns the conjunction of the two diagrams. The <code>prod</code> operation on the <code>r</code> type is used to combine leaf nodes.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val </span>map : f:(<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> g:(<a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map f h t</code> traverses t in post order and first maps the leaves using f, and then the internal nodes using h, producing a modified diagram.</p></dd></dl><dl><dt class="spec value" id="val-dp_map"><a href="#val-dp_map" class="anchor"></a><code><span class="keyword">val </span>dp_map : f:(<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> g:(<a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> find_or_add:(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> default:(unit <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>dp_map f h cache t</code> is equal to <code>map f h t</code>, but uses <code>cache</code> for memoization</p></dd></dl><dl><dt class="spec value" id="val-map_r"><a href="#val-map_r" class="anchor"></a><code><span class="keyword">val </span>map_r : f:(<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <a href="index.html#type-r">r</a>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>map_r f t</code> returns a diagram with the same structure but whose leaf nodes have been modified according the function <code>f</code>.</p><p>This function can be used as a general form of negation. For example, if the <code>r</code> type were <code>bool</code>, one could implement negation in the following way:</p><p><code>let neg = map_r (fun r -&gt; not r)</code></p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">val </span>fold : f:(<a href="index.html#type-r">r</a> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> g:(<a href="index.html#type-v">v</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>) <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>fold f g t</code> traverses the diagram, replacing leaf nodes with applications of <code>f</code> to the values that they hold, and branches on variables with applications of <code>g</code>.</p></dd></dl><dl><dt class="spec value" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p><code>equal a b</code> returns whether or not the two diagrams are structurally equal. If two diagrams are structurally equal, then they represent the same combinatorial object. However, if two diagrams are not equal, they still may represent the same combinatorial object. Whether or not this is the case depends on they behavior of the type <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val </span>sum : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>sum a b</code> returns the disjunction of the two diagrams. The <code>sum</code> operation on the <code>r</code> type is used to combine leaf nodes.</p></dd></dl><dl><dt class="spec value" id="val-prod"><a href="#val-prod" class="anchor"></a><code><span class="keyword">val </span>prod : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>prod a b</code> returns the conjunction of the two diagrams. The <code>prod</code> operation on the <code>r</code> type is used to combine leaf nodes.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-to_string"><a href="#val-to_string" class="anchor"></a><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_string t</code> returns a string representation of the diagram.</p></dd></dl><dl><dt class="spec value" id="val-clear_cache"><a href="#val-clear_cache" class="anchor"></a><code><span class="keyword">val </span>clear_cache : preserve:Core.Int.Set.t <span>&#45;&gt;</span> unit</code></dt><dd><p><code>clear_cache ()</code> clears the internal cache of diagrams.</p></dd></dl><dl><dt class="spec value" id="val-compressed_size"><a href="#val-compressed_size" class="anchor"></a><code><span class="keyword">val </span>compressed_size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>compressed_size t</code> returns the number of nodes in the diagram, duplicates not counted</p></dd></dl><dl><dt class="spec value" id="val-uncompressed_size"><a href="#val-uncompressed_size" class="anchor"></a><code><span class="keyword">val </span>uncompressed_size : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>uncompressed_size t</code> returns the number of nodes in the diagram, duplicates counted</p></dd></dl><dl><dt class="spec value" id="val-to_dot"><a href="#val-to_dot" class="anchor"></a><code><span class="keyword">val </span>to_dot : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dd><p><code>to_dot t</code> returns a string representation of the diagram using the DOT graph description language. The result of this function can be rendered using Graphviz or any other program that supports the DOT language.</p></dd></dl><dl><dt class="spec value" id="val-refs"><a href="#val-refs" class="anchor"></a><code><span class="keyword">val </span>refs : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Core.Int.Set.t</code></dt><dd><p><code>refs t</code> returns set of subdiagrams in this diagram.</p></dd></dl><dl><dt class="spec value" id="val-serialize"><a href="#val-serialize" class="anchor"></a><code><span class="keyword">val </span>serialize : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> string</code></dt><dt class="spec value" id="val-deserialize"><a href="#val-deserialize" class="anchor"></a><code><span class="keyword">val </span>deserialize : string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-render"><a href="#val-render" class="anchor"></a><code><span class="keyword">val </span>render : ?&#8288;format:string <span>&#45;&gt;</span> ?&#8288;title:string <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Compiles the provided Fdd `t` using `graphviz`, and opens the resulting file.</p></dd></dl></div></body></html>